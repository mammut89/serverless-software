{"version":3,"sources":["node_modules/react-router/lib/isActive.js"],"names":["exports","__esModule","_typeof","Symbol","iterator","obj","constructor","default","isActive","_PatternUtils","require","deepEqual","a","b","Array","isArray","length","every","item","index","p","Object","prototype","hasOwnProperty","call","undefined","String","pathIsActive","pathname","currentPathname","charAt","routeIsActive","routes","params","remainingPathname","paramNames","paramValues","i","len","route","pattern","path","matched","matchPattern","concat","paramName","queryIsActive","query","activeQuery","_ref","indexOnly","currentLocation","module"],"mappings":"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","file":"isActive.js","sourceRoot":"/Users/mo/serverless-software","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.default = isActive;\n\nvar _PatternUtils = require('./PatternUtils');\n\nfunction deepEqual(a, b) {\n  if (a == b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return deepEqual(item, b[index]);\n    });\n  }\n\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {\n    for (var p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue;\n      }\n\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false;\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false;\n      } else if (!deepEqual(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return String(a) === String(b);\n}\n\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = '/' + currentPathname;\n  }\n\n  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/';\n  }\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/';\n  }\n\n  return currentPathname === pathname;\n}\n\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\nfunction routeIsActive(pathname, routes, params) {\n  var remainingPathname = pathname,\n      paramNames = [],\n      paramValues = [];\n\n  // for...of would work here but it's probably slower post-transpilation.\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    var route = routes[i];\n    var pattern = route.path || '';\n\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname;\n      paramNames = [];\n      paramValues = [];\n    }\n\n    if (remainingPathname !== null && pattern) {\n      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every(function (paramName, index) {\n          return String(paramValues[index]) === String(params[paramName]);\n        });\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null) return query == null;\n\n  if (query == null) return true;\n\n  return deepEqual(query, activeQuery);\n}\n\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\nfunction isActive(_ref, indexOnly, currentLocation, routes, params) {\n  var pathname = _ref.pathname;\n  var query = _ref.query;\n\n  if (currentLocation == null) return false;\n\n  // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname;\n  }\n\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false;\n    }\n  }\n\n  return queryIsActive(query, currentLocation.query);\n}\nmodule.exports = exports['default'];"]}