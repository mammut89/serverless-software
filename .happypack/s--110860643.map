{"version":3,"sources":["node_modules/history/lib/AsyncUtils.js"],"names":["exports","__esModule","_slice","Array","prototype","slice","loopAsync","turns","work","callback","currentTurn","isDone","sync","hasNext","doneArgs","undefined","done","concat","call","arguments","apply","next"],"mappings":"AAAA;;AAEAA,QAAQC,UAAR,GAAqB,IAArB;AACA,IAAIC,SAASC,MAAMC,SAAN,CAAgBC,KAA7B;AACAL,QAAQM,SAAR,GAAoBA,SAApB;;AAEA,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,IAA1B,EAAgCC,QAAhC,EAA0C;AACxC,MAAIC,cAAc,CAAlB;AAAA,MACIC,SAAS,KADb;AAEA,MAAIC,OAAO,KAAX;AAAA,MACIC,UAAU,KADd;AAAA,MAEIC,WAAWC,SAFf;;AAIA,WAASC,IAAT,GAAgB;AACdL,aAAS,IAAT;AACA,QAAIC,IAAJ,EAAU;AACR;AACAE,iBAAW,GAAGG,MAAH,CAAUf,OAAOgB,IAAP,CAAYC,SAAZ,CAAV,CAAX;AACA;AACD;;AAEDV,aAASW,KAAT,CAAe,IAAf,EAAqBD,SAArB;AACD;;AAED,WAASE,IAAT,GAAgB;AACd,QAAIV,MAAJ,EAAY;AACV;AACD;;AAEDE,cAAU,IAAV;AACA,QAAID,IAAJ,EAAU;AACR;AACA;AACD;;AAEDA,WAAO,IAAP;;AAEA,WAAO,CAACD,MAAD,IAAWD,cAAcH,KAAzB,IAAkCM,OAAzC,EAAkD;AAChDA,gBAAU,KAAV;AACAL,WAAKU,IAAL,CAAU,IAAV,EAAgBR,aAAhB,EAA+BW,IAA/B,EAAqCL,IAArC;AACD;;AAEDJ,WAAO,KAAP;;AAEA,QAAID,MAAJ,EAAY;AACV;AACAF,eAASW,KAAT,CAAe,IAAf,EAAqBN,QAArB;AACA;AACD;;AAED,QAAIJ,eAAeH,KAAf,IAAwBM,OAA5B,EAAqC;AACnCF,eAAS,IAAT;AACAF;AACD;AACF;;AAEDY;AACD","file":"AsyncUtils.js","sourceRoot":"/Users/mo/serverless-software","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nvar _slice = Array.prototype.slice;\nexports.loopAsync = loopAsync;\n\nfunction loopAsync(turns, work, callback) {\n  var currentTurn = 0,\n      isDone = false;\n  var sync = false,\n      hasNext = false,\n      doneArgs = undefined;\n\n  function done() {\n    isDone = true;\n    if (sync) {\n      // Iterate instead of recursing if possible.\n      doneArgs = [].concat(_slice.call(arguments));\n      return;\n    }\n\n    callback.apply(this, arguments);\n  }\n\n  function next() {\n    if (isDone) {\n      return;\n    }\n\n    hasNext = true;\n    if (sync) {\n      // Iterate instead of recursing if possible.\n      return;\n    }\n\n    sync = true;\n\n    while (!isDone && currentTurn < turns && hasNext) {\n      hasNext = false;\n      work.call(this, currentTurn++, next, done);\n    }\n\n    sync = false;\n\n    if (isDone) {\n      // This means the loop finished synchronously.\n      callback.apply(this, doneArgs);\n      return;\n    }\n\n    if (currentTurn >= turns && hasNext) {\n      isDone = true;\n      callback();\n    }\n  }\n\n  next();\n}"]}